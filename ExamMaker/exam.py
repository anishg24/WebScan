#  Copyright (c) 2020. Anish Govind#  https://github.com/anishg24import osimport shutilimport jsonfrom string import ascii_lowercaseimport cv2.aruco as arucoimport pyqrcodeng as qrfrom cv2 import imwritefrom fpdf import FPDF  # Consider switching over to Jinja Template + PDFKit# NOTE:# All these calculations were done via trial and error. If you decide to change constants predefined then end result# may not look the same!# GOLDEN EXPRESSION# self.bubble_coordinates[i].append((x, y, HALF_BUBBLE_SIZE / 2 + x + 0.25 * self.pdf.font_size - 0.3,#                                                    HALF_BUBBLE_SIZE / 2 + y + 0.75 * self.pdf.font_size - 0.1))# EXAMS_FOLDER = os.getcwd() + "/custom_exams/"EXAMS_FOLDER = "../custom_exams/"# TODO DELETE IN PRODUCTIONtry:    shutil.rmtree(os.path.join(os.getcwd(), "created_exams/") + "1")    shutil.rmtree(os.path.join(os.getcwd(), "created_exams/") + "markers")except FileNotFoundError:    passclass Exam(FPDF):    def __init__(self, name, num_questions, num_choices=4):        super().__init__("P", "mm", "A4")        if num_choices > 10:            return        if len(name) > 20:            return        self.directory = os.path.join(os.getcwd(), "created_exams/")        self.marker_directory = os.path.join(self.directory, "markers/")        if not os.path.exists(self.marker_directory):            try:                os.mkdir(self.directory)            except FileExistsError:                pass            os.mkdir(self.marker_directory)        self.name = name        self.num_questions = num_questions        self.num_choices = num_choices        self.questions_on_header = 0        self.questions_on_normal = 0        self.bubble_size = 5        self.marker_size = 24        self.SPACE_CONSTANT = 6        self.page_count = 0        self._generate_markers()        self._generate_id()        self.add_page("P")        self._add_fields_to_paper()        self._add_uid_to_paper()        self._create_exam()    def header(self):        self.image(f"{self.marker_directory}1.png", 10, 8)  # top left        self.image(f"{self.marker_directory}2.png", 186, 8)  # top right        self.image(f"{self.marker_directory}3.png", 10, 265)  # bottom left        self.image(f"{self.directory}{self.exam_id}/qr.png", 150, 235)  # bottom right    def _generate_markers(self):        aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)        li = [aruco.drawMarker(aruco_dict, i + 1, self.marker_size) for i in range(5)]        for i in range(len(li)):            imwrite(f"{self.marker_directory}{i + 1}.png", li[i])    def _generate_id(self):        self.exam_id = len(os.listdir(self.directory))        if not os.path.exists(self.directory + f"{self.exam_id}/"):            os.mkdir(self.directory + f"{self.exam_id}/")        self.ID = (self.exam_id, self.num_questions, self.num_choices)  # QR Code effectively gives all the data across scripts        self.qr_code = qr.create(str(self.ID))        self.qr_code.png(self.directory + f"{self.exam_id}/qr.png", scale=3)    def _question_font_format(self):        self.set_font("Courier", size=8)        self.set_text_color(125, 125, 125)        self.set_line_width(.2)    def _add_fields_to_paper(self):        x = self.w * 0.33        def title(y, text):            self.set_font("Arial", size=32)            self.set_text_color(0, 0, 0)            self.text(x, y, text)        def field(y, text, subtitle=None):            self.set_font("Arial", size=16)            self.set_text_color(0, 0, 0)            self.text(x, y, text)            if subtitle:                self.set_font("Arial", size=8)                self.set_text_color(125, 125, 125)                self.text(x, y + 3, subtitle)        title(20, self.name)        field(30, f"Name: {'_' * 16}")        field(40, f"Date: __/__/__")        field(50, f"Period: __")        field(60, f"Class: {'_' * 16}", "(Optional)")        field(70, f"Teacher: {'_' * 16}", "(Optional)")        field(80, f"Score: __/__", "(Score to be filled by administrator)")        self._question_font_format()    def _add_uid_to_paper(self):        X = 25        Y = 25        self.set_line_width(1)        for i in range(5):            self._create_bubble_group(X + i * self.SPACE_CONSTANT, Y, [str(n) for n in range(10)], False, "box")        self.set_line_width(1)        self.rect(X - 2, Y - 13, 33, Y + 50)        self.header_ends = (33, 90)    def _create_bubble(self, x, y, text=None):        self.ellipse(x, y, self.bubble_size, self.bubble_size)        tx = self.bubble_size / 4 + x + 0.25 * self.font_size - 0.3        ty = self.bubble_size / 4 + y + 0.75 * self.font_size - 0.1        self.text(tx, ty, text)    def _create_bubble_group(self, x, y, choice_names, horizontal=True, label=None):        if label and horizontal:            self.set_font_size(12)            self.set_text_color(0, 0, 0)            self.text(x - (len(label) * 2.7), self.bubble_size / 4 + y + 0.75 * self.font_size - 1, label)        elif label.lower() == "box":            self.set_line_width(.2)            self.rect(x, y - 10, self.bubble_size, 8.5)        self._question_font_format()        for i in range(len(choice_names)):            if horizontal:                self._create_bubble(x + i * self.SPACE_CONSTANT, y, choice_names[i])            else:                self._create_bubble(x, y + i * self.SPACE_CONSTANT, choice_names[i])    def _create_question_column(self, x, y, num, on_header, offset=0):        choices = ascii_lowercase[:self.num_choices]        for i in range(num):            ny = y + i * self.SPACE_CONSTANT            # or offset + i + 1 > self.num_questions            if x > 130 and ny > 230 or offset + i + 1 > self.num_questions:                break            if on_header and len(self.pages) == 1:                self.questions_on_header += 1            elif len(self.pages) == 2:                self.questions_on_normal += 1            self._create_bubble_group(x, ny, choices, label=f"{offset + i + 1}.")            # return num    def _create_exam(self, with_header=True, offset=0):        print(offset)        if with_header:            _, height = self.header_ends        else:            height = 20        bounds = {            "top_left": (23, height),            "top_right": (127, height),            "bottom_left": (23, 265-height),            "bottom_right": (127, 265-height),        }        # self.rect(bounds["top_left"][0], bounds["top_right"][1], bounds["bottom_right"][0], bounds["bottom_right"][1])        rows = int(bounds["bottom_left"][1]/self.SPACE_CONSTANT)        columns = int((bounds["top_right"][0] - bounds["top_left"][0]) / (self.num_choices * 6))        # self.line(130, 0, 130, self.h)        # self.line(0, 230, self.w, 230)        for i in range(columns):            self._create_question_column(23 + (i * (self.SPACE_CONSTANT*2 + self.num_choices * 6)), height, rows, with_header, offset + rows*i)        # print(self.questions_on_normal, self.questions_on_header)        if (self.questions_on_header + (len(self.pages) - 1) * self.questions_on_normal) < self.num_questions:            self.add_page("P")            self._create_exam(False, (self.questions_on_header + (len(self.pages) - 2) * self.questions_on_normal))    def save_pdf(self):        self.output(f"{self.directory}{self.exam_id}/paper.pdf")        options = {'id': self.exam_id,                   'num_questions': self.num_questions,                   'num_choices': self.num_choices,                   'pages': len(self.pages)}        with open(f"{self.directory}{self.exam_id}/options.json", "w+") as file:            file.write(json.dumps(options))    def get_directory(self):        return self.directory# a = Exam("Unit 10 MCQ", 360, 4)# a.save_pdf()# print(a.ID)# print("CREATED TEST")